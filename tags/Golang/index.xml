<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Golang on Mr.耗子</title>
    <link>http://blog.k-8s.com/tags/Golang/</link>
    <description>Recent content in Golang on Mr.耗子</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Sat, 19 Oct 2019 10:23:13 +0800</lastBuildDate>
    
	<atom:link href="http://blog.k-8s.com/tags/Golang/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Golang 安全编程</title>
      <link>http://blog.k-8s.com/posts/Golang-Note/Golang-secure-programming/</link>
      <pubDate>Sat, 19 Oct 2019 10:23:13 +0800</pubDate>
      
      <guid>http://blog.k-8s.com/posts/Golang-Note/Golang-secure-programming/</guid>
      <description>&lt;h3 id=&#34;安全编程&#34;&gt;安全编程&lt;/h3&gt;

&lt;h4 id=&#34;数据加密&#34;&gt;数据加密&lt;/h4&gt;

&lt;p&gt;采用单密钥的加密算法, 称为对称加密. 常见的算法有 DES, AES, RC4 等&lt;/p&gt;

&lt;p&gt;采用双密钥的加密算法, 称为非对称加密. 私钥加密的密文, 只有公钥能解密, 反过来也一样. 常见的算法有 RSA 等&lt;/p&gt;

&lt;p&gt;在对称加密中, 密钥是不能公开的; 而非对称加密中, 公钥是公开的, 私钥是保密的&lt;/p&gt;

&lt;p&gt;某些情况下, 不需要对密文进行解密, 例如哈希算法等. 常见的哈希算法包括 MD5, SHA-1, SHA-256 等&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Golang 网络编程</title>
      <link>http://blog.k-8s.com/posts/Golang-Note/Golang-network-programming/</link>
      <pubDate>Fri, 18 Oct 2019 13:32:35 +0800</pubDate>
      
      <guid>http://blog.k-8s.com/posts/Golang-Note/Golang-network-programming/</guid>
      <description>&lt;p&gt;Go 语言标准库提供 net 包, 支持基于 IP 层, TCP/UDP 层及更高层面 (如 HTTP, FTP, SMTP) 的网络操作&lt;/p&gt;

&lt;h3 id=&#34;socket-编程&#34;&gt;Socket 编程&lt;/h3&gt;

&lt;p&gt;传统的 Socket 编程方式大致会有以下几个步骤:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;建立 Socket: 使用 socket() 函数&lt;/li&gt;
&lt;li&gt;绑定 Socket: 使用 bind() 函数&lt;/li&gt;
&lt;li&gt;监听: 使用 listen() 函数, 或者连接: 使用 connect() 函数&lt;/li&gt;
&lt;li&gt;接受连接: 使用 accept() 函数&lt;/li&gt;
&lt;li&gt;接受: 使用 receive() 函数, 或者发送: 使用 send() 函数&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;而 Go 标准库对对此过程进行了抽象和封装, 无论我们期望使用协议建立什么形式的连接, 都只需要调用 net.Dial() 即可&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Golang 并发编程</title>
      <link>http://blog.k-8s.com/posts/Golang-Note/Golang-concurrency/</link>
      <pubDate>Wed, 16 Oct 2019 20:16:15 +0800</pubDate>
      
      <guid>http://blog.k-8s.com/posts/Golang-Note/Golang-concurrency/</guid>
      <description>&lt;h3 id=&#34;并发编程&#34;&gt;并发编程&lt;/h3&gt;

&lt;p&gt;并发实现模型有有以下几种主流模型:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;多进程&lt;/strong&gt;: 开销最大, 进程与进程间互不影响&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;多线程&lt;/strong&gt;: 比多进程开销小, 高并发下效率有影响&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;基于回调的非阻塞/异步IO&lt;/strong&gt;: 高并发服务器上, 多线程会很快耗尽服务器的内存和 CPU 资源. 使用异步 IO, 且尽可能的少用线程, 可以很好的降低开销&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;协程&lt;/strong&gt;: 本质上是一种用户态下城, 寄存于线程中, 开销非常小, 不需要操作系统来进行抢占式调度. 缺点是需要编程语言支持, 若语言不支持, 需要用户自行实现调度器&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;&amp;ldquo;共享内存系统&amp;rdquo;&lt;/strong&gt;: 线程类并发模式中, 线程间通信只能采用共享内存的方式, 为了保证内存的有效性, 我们会给共享内存加锁等来避免资源竞争&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&amp;ldquo;消息传递系统&amp;rdquo;&lt;/strong&gt;: 对线程共享状态的各种操作都被封装在线程之间传递的消息中. 由于在发送消息是需要对状态进行复制, 并且在消息传递边界上交出这个状态的所有权. 所以大多数消息传递的实现在性能上并不优越, 但线程中的状态管理工作会变得更为简单&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Golang 接口</title>
      <link>http://blog.k-8s.com/posts/Golang-Note/Golang-interface/</link>
      <pubDate>Tue, 15 Oct 2019 10:24:05 +0800</pubDate>
      
      <guid>http://blog.k-8s.com/posts/Golang-Note/Golang-interface/</guid>
      <description>&lt;h3 id=&#34;接口&#34;&gt;接口&lt;/h3&gt;

&lt;p&gt;Go 语言中的接口不是其他语言中的接口所提供的接口概念&lt;/p&gt;

&lt;p&gt;在 Go 出现之前, 接口主要作为不通组件之间的契约存在, 对契约的实现是强制的, 必须声明你的确是实现了该接口&lt;/p&gt;

&lt;p&gt;在 Go 语言中的接口类型是一种抽象的类型. 它不会暴露出&lt;code&gt;它所代表的对象的内部值的结构&lt;/code&gt;和&lt;code&gt;这个对象支持的基础操作的集合&lt;/code&gt;, 它只会展示出他们自己的方法.&lt;/p&gt;

&lt;p&gt;也就是说, 当你看到一个接口类型的值时, 你不知道它是什么, 唯一知道的就是可以通过它的方法来做什么&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Golang 类型系统</title>
      <link>http://blog.k-8s.com/posts/Golang-Note/Golang-type-system/</link>
      <pubDate>Mon, 14 Oct 2019 10:03:41 +0800</pubDate>
      
      <guid>http://blog.k-8s.com/posts/Golang-Note/Golang-type-system/</guid>
      <description>&lt;h3 id=&#34;类型系统&#34;&gt;类型系统&lt;/h3&gt;

&lt;p&gt;类型系统是指一个语言的类型体系结构, 是一门编程语言的地基&lt;/p&gt;

&lt;p&gt;一个典型的类型系统通常包含如下基本内容:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;基础类型, 如 &lt;strong&gt;byte&lt;/strong&gt;, &lt;strong&gt;int&lt;/strong&gt;, &lt;strong&gt;bool&lt;/strong&gt;, &lt;strong&gt;floot&lt;/strong&gt; 等&lt;/li&gt;
&lt;li&gt;复合类型, 如&lt;strong&gt;数组&lt;/strong&gt;, &lt;strong&gt;结构体&lt;/strong&gt;, &lt;strong&gt;指针&lt;/strong&gt;等&lt;/li&gt;
&lt;li&gt;可以指向任意对象的类型(Any 类型)&lt;/li&gt;
&lt;li&gt;值语义和引用语义&lt;/li&gt;
&lt;li&gt;面向对象, 即所有具备面向对象特征的类型&lt;/li&gt;
&lt;li&gt;接口&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Go 语言中的大多数类型都是值语义, 并且都可以包含对应的操作方法. 在需要的时候, 你可以给任何类型 (包括内置类型) &amp;ldquo;增加&amp;rdquo; 新的方法. 而在实现某个接口时, 无需从该接口继承 (实际上, Go 语言不支持面向对象中的&lt;strong&gt;继承&lt;/strong&gt;语法), 只需要实现该接口要求的所有方法即可&lt;/p&gt;

&lt;p&gt;任意类型都可以被 &lt;strong&gt;&lt;em&gt;Any类型&lt;/em&gt;&lt;/strong&gt; 引用. &lt;strong&gt;&lt;em&gt;Any类型&lt;/em&gt;&lt;/strong&gt; 就是空接口, 即 &lt;strong&gt;&lt;em&gt;interface{}&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Golang 错误处理</title>
      <link>http://blog.k-8s.com/posts/Golang-Note/Golang-error-handling/</link>
      <pubDate>Sun, 13 Oct 2019 20:17:18 +0800</pubDate>
      
      <guid>http://blog.k-8s.com/posts/Golang-Note/Golang-error-handling/</guid>
      <description>&lt;h3 id=&#34;错误处理&#34;&gt;错误处理&lt;/h3&gt;

&lt;h3 id=&#34;一-error-接口&#34;&gt;一. error 接口&lt;/h3&gt;

&lt;p&gt;Go 引入了一个关于错误处理的标准模式, 即 &lt;strong&gt;&lt;em&gt;error&lt;/em&gt;&lt;/strong&gt; 接口, 定义如下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type error interface {
    Error() string
}

// 对于大多数函数, 如果要返回错误, 大致上可以定义为如下模式, 将 error 作为多返回结果的最后一个
func Foo(param int) (n int, err error) {
    ...
}

// 调用时错误处理格式
n, err := Foo(0)

if err != nil {
    // 错误处理
} else {
    // 使用返回值n
}
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>Golang 函数</title>
      <link>http://blog.k-8s.com/posts/Golang-Note/Golang-function/</link>
      <pubDate>Sun, 13 Oct 2019 09:18:45 +0800</pubDate>
      
      <guid>http://blog.k-8s.com/posts/Golang-Note/Golang-function/</guid>
      <description>&lt;h3 id=&#34;函数&#34;&gt;函数&lt;/h3&gt;

&lt;p&gt;函数的基本组成为:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;关键字 &lt;strong&gt;&lt;em&gt;func&lt;/em&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;函数名&lt;/li&gt;
&lt;li&gt;参数列表&lt;/li&gt;
&lt;li&gt;返回值&lt;/li&gt;
&lt;li&gt;函数体&lt;/li&gt;
&lt;li&gt;返回语句&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Golang 流程控制</title>
      <link>http://blog.k-8s.com/posts/Golang-Note/Golang-process-control/</link>
      <pubDate>Sat, 12 Oct 2019 15:16:24 +0800</pubDate>
      
      <guid>http://blog.k-8s.com/posts/Golang-Note/Golang-process-control/</guid>
      <description>&lt;h3 id=&#34;流程控制&#34;&gt;流程控制&lt;/h3&gt;

&lt;p&gt;流程控制语句, 用于设定计算执行的次序, 简历程序的逻辑结构&lt;/p&gt;

&lt;p&gt;流程控制语句一般起以下三个作用:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;选择&lt;/li&gt;
&lt;li&gt;循环&lt;/li&gt;
&lt;li&gt;跳转&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Go 语言中支持如下几种流程控制语句:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;条件语句: &lt;strong&gt;&lt;em&gt;if&lt;/em&gt;&lt;/strong&gt;, &lt;strong&gt;&lt;em&gt;else&lt;/em&gt;&lt;/strong&gt; 和 &lt;strong&gt;&lt;em&gt;else if&lt;/em&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;选择语句: &lt;strong&gt;&lt;em&gt;switch&lt;/em&gt;&lt;/strong&gt;, &lt;strong&gt;&lt;em&gt;case&lt;/em&gt;&lt;/strong&gt; 和 &lt;strong&gt;&lt;em&gt;select&lt;/em&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;循环语句: &lt;strong&gt;&lt;em&gt;for&lt;/em&gt;&lt;/strong&gt; 和 &lt;strong&gt;&lt;em&gt;range&lt;/em&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;跳转语句: &lt;strong&gt;&lt;em&gt;goto&lt;/em&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;为了能在具体的场景中满足更丰富的控制需求, Go 语言还增加了如下关键字: break, continue 和 fallthrough&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Golang 数据类型</title>
      <link>http://blog.k-8s.com/posts/Golang-Note/Golang-type-of-data/</link>
      <pubDate>Sat, 12 Oct 2019 10:23:08 +0800</pubDate>
      
      <guid>http://blog.k-8s.com/posts/Golang-Note/Golang-type-of-data/</guid>
      <description>&lt;h3 id=&#34;数据类型&#34;&gt;数据类型&lt;/h3&gt;

&lt;p&gt;Golang 中内置以下基础类型:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;布尔类型  bool&lt;/li&gt;
&lt;li&gt;整形  int uint int8 int16 byte uintptr&lt;/li&gt;
&lt;li&gt;浮点类型  float32 float64&lt;/li&gt;
&lt;li&gt;复数类型  complex64 complex128&lt;/li&gt;
&lt;li&gt;字符串  string&lt;/li&gt;
&lt;li&gt;字符类型  rune&lt;/li&gt;
&lt;li&gt;错误类型  error&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;此外, Golang 也支持以下复合类型:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;指针  (pointer)&lt;/li&gt;
&lt;li&gt;数组  (array)&lt;/li&gt;
&lt;li&gt;切片  (slice)&lt;/li&gt;
&lt;li&gt;字典  (map)&lt;/li&gt;
&lt;li&gt;通道  (chan)&lt;/li&gt;
&lt;li&gt;结构体  (struct)&lt;/li&gt;
&lt;li&gt;接口  (interface)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;另外, 还有错误类型, 这里暂不过多介绍&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Golang 变量与常量</title>
      <link>http://blog.k-8s.com/posts/Golang-Note/Golang-variables-and-constants/</link>
      <pubDate>Tue, 08 Oct 2019 10:02:42 +0800</pubDate>
      
      <guid>http://blog.k-8s.com/posts/Golang-Note/Golang-variables-and-constants/</guid>
      <description>&lt;p&gt;&lt;strong&gt;前置学习:&lt;/strong&gt; 第一个 Go 程序&lt;/p&gt;

&lt;p&gt;学习编程惯例, 先放一个 Hello, World! 程序上来:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

func main() {
    // First Go program
	fmt.Println(&amp;quot;Hello, world!&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一个简单的 Go 语言程序如上, Go 源码 文件开头都是一个 package 声明, 表示该 Go 源码文件所属的包&lt;/p&gt;

&lt;p&gt;包是 Go 语言里最基本的分发单位. 若要生成可执行程序, 必须建立一个名字为 main 的包, 并且在该包中包含一个 叫 main() 的函数.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;main() 函数不能带参数, 也不能定义返回值&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Golang 安装和环境配置</title>
      <link>http://blog.k-8s.com/posts/Golang-Note/Golang-install-and-env/</link>
      <pubDate>Tue, 08 Oct 2019 09:30:42 +0800</pubDate>
      
      <guid>http://blog.k-8s.com/posts/Golang-Note/Golang-install-and-env/</guid>
      <description>&lt;h3 id=&#34;安装&#34;&gt;安装&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Golang 配置方式分为两种&lt;/strong&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Go Modules包管理模式&lt;/li&gt;
&lt;li&gt;原始GOPATH模式&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;前提&lt;/strong&gt;:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Golang &lt;a href=&#34;https://golang.org&#34;&gt;官网&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Golang &lt;a href=&#34;https://golang.google.cn&#34;&gt;国内官网&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;GoModules配置 &lt;a href=&#34;https://segmentfault.com/a/1190000018690961&#34;&gt;思否&lt;/a&gt; &lt;a href=&#34;https://www.jishuwen.com/d/2n6e&#34;&gt;技术文&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</description>
    </item>
    
  </channel>
</rss>